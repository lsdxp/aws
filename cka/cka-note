structure:

master:
kube-apiserver 
etcd
kube controller
kube-scheduler

worker:
kube-let
kube-proxy
docker/container runtime

kubectl exec etcd-master -n kube-system -- sh -c "ETCDCTL_API=3 etcdctl get / --prefix --keys-only --limit=10 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt  --key /etc/kubernetes/pki/etcd/server.key" 

kubeadm doesn't install kubelet

pod yaml:

apiversion
kind
metadata -> dict

spec -> list

https://kubernetes.io/docs/reference/kubectl/cheatsheet/

commands: 
kubectl run nginx --image=nginx
kubectl describe pod pod-name
kubectl get pods -o wide
kubectl run redis --image=redis123 --dry-run=client -o yaml > pod.yml
kubectl apply -f pod.yml
kubectl edit pod redis


--------------
replication controller vs replica set

replica set -> selector and matchlabels

kubectl replace -f replicaset-definition.yml
kubectl scale --replicas=6 -f replicaset-definition.yml
kubectl scale --replicas=6 replicaset myapp-replicaset
kubectl get replicaset
kubectl delete replicaset myapp-replicaset

---------
kind: Deployment
kubectl get deployments
kubectl get all

https://kubernetes.io/docs/reference/kubectl/conventions/


-----
namespace

kubectl config set-context $(kubectl config current-context)  --namespace=dev
kubectl get pods --all-namespaces
kubectl get pods --namespace=dev

db-service.dev.svc.cluster.local (pod namespace service domain)

------
service

Nodeport, clusterIP, load balancer
kubectl expose deployment simple-webapp-deployment --name=webapp-service --target-port=8080 --type=NodePort --port=8080 --dry-run=client -o yaml

---------
scheduler
spec->nodeName 
-------
label
kubectl get pods --selector app=App1
kubectl get pods --selector bu=finance,env=prod,tier=frontend

----
taint effect: NoSchedule|PreferNoSchedule|NoExecute
kubectl taint nodes node1 app=blue:NoSchedule
untaint: kubectl taint nodes controlplane node-role.kubernetes.io/master:NoSchedule-

----
nodeSelector
kubectl label nodes node01 size=Large

node affinity

requiredDuringSchedulingIgnoredExecution
kubectl get deployment.apps blue -o yaml > pod.yml

--------
dameon set, one pod each node

-----
static pod

/etc/kubenetes/manifes/
--pod-manifest-path
--config -> staticPodPath

-------
multi scheduler
scheduleName in pod config
-----
https://github.com/kodekloudhub/kubernetes-metrics-server.git
kubectl top node
------
kubectl logs -f pod-name (container name if multiple)

------
kubectl rollout status deployment/myapp-deployment
kubectl rollout history deployment/myapp-deployment
kubectl rollout undo deployment/myapp-deployment

------
docker run --entrypoint sleep2.0 ubuntu-sleeper 10

under container
ENTRYPOINT-> command:
                - sleep2.0
                - "1200"
CMD-> args:
        - "10"

env:
   - name:
    value:
    
env:
   - name: APP_COLOR
    valueFrom:   
        configMapKeyRef:
          name: app-config
          key: APP_COLOR
envFrom:
    - configMapRef:
      name: app-config
      
volumes:
- name: app-config-volume
  configMap:
    name: app-config
kubectl create configmap app-config --from-literal=APP_COLOR=blue
kubectl create configmap app-config --from-file=app_config.properties
kubectl create -f config-map.yaml
kubectl get configmaps

kubectl create secret generic app-secret --from-literal=DB_HOST=mysql
kubectl create secret generic app-secret --from-file=app_secret.properties
kubectl create -f app-secret.yaml

echo -n 'mysql' | base64
kubectl get secrets

echo -n 'bX1zcWw-' | base64 --decode

volumes:
- name: app-secret-volume
  secret:
    secretName: app-secret

envFrom:
- secretRef:
            name: db-secret
            
---------
There are 3 common patterns, when it comes to designing multi-container PODs. 
The first and what we just saw with the logging service example is known as a side car pattern. 
The others are the adapter and the ambassador pattern.

------------
initContainers

------
cluster maintainence

kubectl drain node01
kubectl cordon node01
kubectl uncordon node01

kubeadm upgrade plan
-----------

On the controlplane node, run the command run the following commands:

apt update
This will update the package lists from the software repository.

apt install kubeadm=1.20.0-00
This will install the kubeadm version 1.20

kubeadm upgrade apply v1.20.0
This will upgrade kubernetes controlplane. Note that this can take a few minutes.

apt install kubelet=1.20.0-00 This will update the kubelet with the version 1.20.

You may need to restart kubelet after it has been upgraded.
Run: systemctl restart kubelet

--------------------------------
If you are on the master node, run ssh node01 to go to node01


apt update
This will update the package lists from the software repository.


apt install kubeadm=1.20.0-00
This will install the kubeadm version 1.20


kubeadm upgrade node
This will upgrade the node01 configuration.


apt install kubelet=1.20.0-00 This will update the kubelet with the version 1.20.


You may need to restart kubelet after it has been upgraded.
Run: systemctl restart kubelet

----------

